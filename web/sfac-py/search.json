[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Python",
    "section": "",
    "text": "Figure 1: Official logo of the Python programming language\n\n\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "inst-221019.html",
    "href": "inst-221019.html",
    "title": "inst-221019",
    "section": "",
    "text": "To start, we must import the necessary libraries: Pandas for data frames and Altair for visualization.\n\nimport pandas as pd\nimport altair as alt"
  },
  {
    "objectID": "inst-221019.html#renderers",
    "href": "inst-221019.html#renderers",
    "title": "inst-221019",
    "section": "Renderers",
    "text": "Renderers\nDepending on your environment, you may need to specify a renderer for Altair. If you are using JupyterLab, Jupyter Notebook, or Google Colab with a live Internet connection you should not need to do anything. Otherwise, please read the documentation for Displaying Altair Charts."
  },
  {
    "objectID": "inst-221019.html#data",
    "href": "inst-221019.html#data",
    "title": "inst-221019",
    "section": "Data",
    "text": "Data\nData in Altair is built around the Pandas data frame, which consists of a set of named data columns. We will also regularly refer to data columns as data fields.\nWhen using Altair, datasets are commonly provided as data frames. Alternatively, Altair can also accept a URL to load a network-accessible dataset. As we will see, the named columns of the data frame are an essential piece of plotting with Altair.\nWe will often use datasets from the vega-datasets repository. Some of these datasets are directly available as Pandas data frames:\n\nfrom vega_datasets import data  # import vega_datasets\ncars = data.cars()              # load cars data as a Pandas data frame\ncars.head()                     # display the first five rows\n\n\n\n\n\n  \n    \n      \n      Name\n      Miles_per_Gallon\n      Cylinders\n      Displacement\n      Horsepower\n      Weight_in_lbs\n      Acceleration\n      Year\n      Origin\n    \n  \n  \n    \n      0\n      chevrolet chevelle malibu\n      18.0\n      8\n      307.0\n      130.0\n      3504\n      12.0\n      1970-01-01\n      USA\n    \n    \n      1\n      buick skylark 320\n      15.0\n      8\n      350.0\n      165.0\n      3693\n      11.5\n      1970-01-01\n      USA\n    \n    \n      2\n      plymouth satellite\n      18.0\n      8\n      318.0\n      150.0\n      3436\n      11.0\n      1970-01-01\n      USA\n    \n    \n      3\n      amc rebel sst\n      16.0\n      8\n      304.0\n      150.0\n      3433\n      12.0\n      1970-01-01\n      USA\n    \n    \n      4\n      ford torino\n      17.0\n      8\n      302.0\n      140.0\n      3449\n      10.5\n      1970-01-01\n      USA\n    \n  \n\n\n\n\nDatasets in the vega-datasets collection can also be accessed via URLs:\n\ndata.cars.url\n\n'https://cdn.jsdelivr.net/npm/vega-datasets@v1.29.0/data/cars.json'\n\n\nDataset URLs can be passed directly to Altair (for supported formats like JSON and CSV), or loaded into a Pandas data frame like so:\n\npd.read_json(data.cars.url).head() # load JSON data into a data frame\n\n\n\n\n\n  \n    \n      \n      Name\n      Miles_per_Gallon\n      Cylinders\n      Displacement\n      Horsepower\n      Weight_in_lbs\n      Acceleration\n      Year\n      Origin\n    \n  \n  \n    \n      0\n      chevrolet chevelle malibu\n      18.0\n      8\n      307.0\n      130.0\n      3504\n      12.0\n      1970-01-01\n      USA\n    \n    \n      1\n      buick skylark 320\n      15.0\n      8\n      350.0\n      165.0\n      3693\n      11.5\n      1970-01-01\n      USA\n    \n    \n      2\n      plymouth satellite\n      18.0\n      8\n      318.0\n      150.0\n      3436\n      11.0\n      1970-01-01\n      USA\n    \n    \n      3\n      amc rebel sst\n      16.0\n      8\n      304.0\n      150.0\n      3433\n      12.0\n      1970-01-01\n      USA\n    \n    \n      4\n      ford torino\n      17.0\n      8\n      302.0\n      140.0\n      3449\n      10.5\n      1970-01-01\n      USA\n    \n  \n\n\n\n\nFor more information about data frames - and some useful transformations to prepare Pandas data frames for plotting with Altair! - see the Specifying Data with Altair documentation.\n\nWeather Data\nStatistical visualization in Altair begins with “tidy” data frames. Here, we’ll start by creating a simple data frame (df) containing the average precipitation (precip) for a given city and month :\n\ndf = pd.DataFrame({\n    'city': ['Seattle', 'Seattle', 'Seattle', 'New York', 'New York', 'New York', 'Chicago', 'Chicago', 'Chicago'],\n    'month': ['Apr', 'Aug', 'Dec', 'Apr', 'Aug', 'Dec', 'Apr', 'Aug', 'Dec'],\n    'precip': [2.68, 0.87, 5.31, 3.94, 4.13, 3.58, 3.62, 3.98, 2.56]\n})\n\ndf\n\n\n\n\n\n  \n    \n      \n      city\n      month\n      precip\n    \n  \n  \n    \n      0\n      Seattle\n      Apr\n      2.68\n    \n    \n      1\n      Seattle\n      Aug\n      0.87\n    \n    \n      2\n      Seattle\n      Dec\n      5.31\n    \n    \n      3\n      New York\n      Apr\n      3.94\n    \n    \n      4\n      New York\n      Aug\n      4.13\n    \n    \n      5\n      New York\n      Dec\n      3.58\n    \n    \n      6\n      Chicago\n      Apr\n      3.62\n    \n    \n      7\n      Chicago\n      Aug\n      3.98\n    \n    \n      8\n      Chicago\n      Dec\n      2.56"
  },
  {
    "objectID": "inst-221019.html#the-chart-object",
    "href": "inst-221019.html#the-chart-object",
    "title": "inst-221019",
    "section": "The Chart Object",
    "text": "The Chart Object\nThe fundamental object in Altair is the Chart, which takes a data frame as a single argument:\n\nchart = alt.Chart(df)\n\nSo far, we have defined the Chart object and passed it the simple data frame we generated above. We have not yet told the chart to do anything with the data."
  },
  {
    "objectID": "inst-221019.html#marks-and-encodings",
    "href": "inst-221019.html#marks-and-encodings",
    "title": "inst-221019",
    "section": "Marks and Encodings",
    "text": "Marks and Encodings\nWith a chart object in hand, we can now specify how we would like the data to be visualized. We first indicate what kind of graphical mark (geometric shape) we want to use to represent the data. We can set the mark attribute of the chart object using the the Chart.mark_* methods.\nFor example, we can show the data as a point using Chart.mark_point():\n\nalt.Chart(df).mark_point()\n\n\n\n\n\n\nHere the rendering consists of one point per row in the dataset, all plotted on top of each other, since we have not yet specified positions for these points.\nTo visually separate the points, we can map various encoding channels, or channels for short, to fields in the dataset. For example, we could encode the field city of the data using the y channel, which represents the y-axis position of the points. To specify this, use the encode method:\n\nalt.Chart(df).mark_point().encode(\n  y='city',\n)\n\n\n\n\n\n\nThe encode() method builds a key-value mapping between encoding channels (such as x, y, color, shape, size, etc.) to fields in the dataset, accessed by field name. For Pandas data frames, Altair automatically determines an appropriate data type for the mapped column, which in this case is the nominal type, indicating unordered, categorical values.\nThough we’ve now separated the data by one attribute, we still have multiple points overlapping within each category. Let’s further separate these by adding an x encoding channel, mapped to the 'precip' field:\n\nalt.Chart(df).mark_point().encode(\n    x='precip',\n    y='city'\n)\n\n\n\n\n\n\nSeattle exhibits both the least-rainiest and most-rainiest months!\nThe data type of the 'precip' field is again automatically inferred by Altair, and this time is treated as a quantitative type (that is, a real-valued number). We see that grid lines and appropriate axis titles are automatically added as well.\nAbove we have specified key-value pairs using keyword arguments (x='precip'). In addition, Altair provides construction methods for encoding definitions, using the syntax alt.X('precip'). This alternative is useful for providing more parameters to an encoding, as we will see later in this notebook.\n\nalt.Chart(df).mark_point().encode(\n    alt.X('precip'),\n    alt.Y('city')\n)\n\n\n\n\n\n\nThe two styles of specifying encodings can be interleaved: x='precip', alt.Y('city') is also a valid input to the encode function.\nIn the examples above, the data type for each field is inferred automatically based on its type within the Pandas data frame. We can also explicitly indicate the data type to Altair by annotating the field name:\n\n'b:N' indicates a nominal type (unordered, categorical data),\n'b:O' indicates an ordinal type (rank-ordered data),\n'b:Q' indicates a quantitative type (numerical data with meaningful magnitudes), and\n'b:T' indicates a temporal type (date/time data)\n\nFor example, alt.X('precip:N').\nExplicit annotation of data types is necessary when data is loaded from an external URL directly by Vega-Lite (skipping Pandas entirely), or when we wish to use a type that differs from the type that was automatically inferred.\nWhat do you think will happen to our chart above if we treat precip as a nominal or ordinal variable, rather than a quantitative variable? Modify the code above and find out!\nWe will take a closer look at data types and encoding channels in the next notebook of the data visualization curriculum."
  },
  {
    "objectID": "inst-221019.html#data-transformation-aggregation",
    "href": "inst-221019.html#data-transformation-aggregation",
    "title": "inst-221019",
    "section": "Data Transformation: Aggregation",
    "text": "Data Transformation: Aggregation\nTo allow for more flexibility in how data are visualized, Altair has a built-in syntax for aggregation of data. For example, we can compute the average of all values by specifying an aggregation function along with the field name:\n\nalt.Chart(df).mark_point().encode(\n    x='average(precip)',\n    y='city'\n)\n\n\n\n\n\n\nNow within each x-axis category, we see a single point reflecting the average of the values within that category.\nDoes Seattle really have the lowest average precipitation of these cities? (It does!) Still, how might this plot mislead? Which months are included? What counts as precipitation?\nAltair supports a variety of aggregation functions, including count, min (minimum), max (maximum), average, median, and stdev (standard deviation). In a later notebook, we will take a tour of data transformations, including aggregation, sorting, filtering, and creation of new derived fields using calculation formulas."
  },
  {
    "objectID": "inst-221019.html#changing-the-mark-type",
    "href": "inst-221019.html#changing-the-mark-type",
    "title": "inst-221019",
    "section": "Changing the Mark Type",
    "text": "Changing the Mark Type\nLet’s say we want to represent our aggregated values using rectangular bars rather than circular points. We can do this by replacing Chart.mark_point with Chart.mark_bar:\n\nalt.Chart(df).mark_bar().encode(\n    x='average(precip)',\n    y='city'\n)\n\n\n\n\n\n\nBecause the nominal field a is mapped to the y-axis, the result is a horizontal bar chart. To get a vertical bar chart, we can simply swap the x and y keywords:\n\nalt.Chart(df).mark_bar().encode(\n    x='city',\n    y='average(precip)'\n)"
  },
  {
    "objectID": "inst-221019.html#customizing-a-visualization",
    "href": "inst-221019.html#customizing-a-visualization",
    "title": "inst-221019",
    "section": "Customizing a Visualization",
    "text": "Customizing a Visualization\nBy default Altair / Vega-Lite make some choices about properties of the visualization, but these can be changed using methods to customize the look of the visualization. For example, we can specify the axis titles using the axis attribute of channel classes, we can modify scale properties using the scale attribute, and we can specify the color of the marking by setting the color keyword of the Chart.mark_* methods to any valid CSS color string:\n\nalt.Chart(df).mark_point(color='firebrick').encode(\n  alt.X('precip', scale=alt.Scale(type='log'), axis=alt.Axis(title='Log-Scaled Values')),\n  alt.Y('city', axis=alt.Axis(title='Category')),\n)\n\n\n\n\n\n\nA subsequent module will explore the various options available for scales, axes, and legends to create customized charts."
  },
  {
    "objectID": "inst-221019.html#multiple-views",
    "href": "inst-221019.html#multiple-views",
    "title": "inst-221019",
    "section": "Multiple Views",
    "text": "Multiple Views\nAs we’ve seen above, the Altair Chart object represents a plot with a single mark type. What about more complicated diagrams, involving multiple charts or layers? Using a set of view composition operators, Altair can take multiple chart definitions and combine them to create more complex views.\nAs a starting point, let’s plot the cars dataset in a line chart showing the average mileage by the year of manufacture:\n\nalt.Chart(cars).mark_line().encode(\n    alt.X('Year'),\n    alt.Y('average(Miles_per_Gallon)')\n)\n\n\n\n\n\n\nTo augment this plot, we might like to add circle marks for each averaged data point. (The circle mark is just a convenient shorthand for point marks that used filled circles.)\nWe can start by defining each chart separately: first a line plot, then a scatter plot. We can then use the layer operator to combine the two into a layered chart. Here we use the shorthand + (plus) operator to invoke layering:\n\nline = alt.Chart(cars).mark_line().encode(\n    alt.X('Year'),\n    alt.Y('average(Miles_per_Gallon)')\n)\n\npoint = alt.Chart(cars).mark_circle().encode(\n    alt.X('Year'),\n    alt.Y('average(Miles_per_Gallon)')\n)\n\nline + point\n\n\n\n\n\n\nWe can also create this chart by reusing and modifying a previous chart definition! Rather than completely re-write a chart, we can start with the line chart, then invoke the mark_point method to generate a new chart definition with a different mark type:\n\nmpg = alt.Chart(cars).mark_line().encode(\n    alt.X('Year'),\n    alt.Y('average(Miles_per_Gallon)')\n)\n\nmpg + mpg.mark_circle()\n\n\n\n\n\n\n(The need to place points on lines is so common, the line mark also includes a shorthand to generate a new layer for you. Trying adding the argument point=True to the mark_line method!)\nNow, what if we’d like to see this chart alongside other plots, such as the average horsepower over time?\nWe can use concatenation operators to place multiple charts side-by-side, either vertically or horizontally. Here, we’ll use the | (pipe) operator to perform horizontal concatenation of two charts:\n\nhp = alt.Chart(cars).mark_line().encode(\n    alt.X('Year'),\n    alt.Y('average(Horsepower)')\n)\n\n(mpg + mpg.mark_circle()) | (hp + hp.mark_circle())\n\n\n\n\n\n\nWe can see that, in this dataset, over the 1970s and early ’80s the average fuel efficiency improved while the average horsepower decreased.\nA later notebook will focus on view composition, including not only layering and concatenation, but also the facet operator for splitting data into sub-plots and the repeat operator to concisely generate concatenated charts from a template."
  },
  {
    "objectID": "inst-221019.html#interactivity",
    "href": "inst-221019.html#interactivity",
    "title": "inst-221019",
    "section": "Interactivity",
    "text": "Interactivity\nIn addition to basic plotting and view composition, one of Altair and Vega-Lite’s most exciting features is its support for interaction.\nTo create a simple interactive plot that supports panning and zooming, we can invoke the interactive() method of the Chart object. In the chart below, click and drag to pan or use the scroll wheel to zoom:\n\nalt.Chart(cars).mark_point().encode(\n    x='Horsepower',\n    y='Miles_per_Gallon',\n    color='Origin',\n).interactive()\n\n\n\n\n\n\nTo provide more details upon mouse hover, we can use the tooltip encoding channel:\n\nalt.Chart(cars).mark_point().encode(\n    x='Horsepower',\n    y='Miles_per_Gallon',\n    color='Origin',\n    tooltip=['Name', 'Origin'] # show Name and Origin in a tooltip\n).interactive()\n\n\n\n\n\n\nFor more complex interactions, such as linked charts and cross-filtering, Altair provides a selection abstraction for defining interactive selections and then binding them to components of a chart. We will cover this is in detail in a later notebook.\nBelow is a more complex example. The upper histogram shows the count of cars per year and uses an interactive selection to modify the opacity of points in the lower scatter plot, which shows horsepower versus mileage.\nDrag out an interval in the upper chart and see how it affects the points in the lower chart. As you examine the code, don’t worry if parts don’t make sense yet! This is an aspirational example, and we will fill in all the needed details over the course of the different notebooks.\n\n# create an interval selection over an x-axis encoding\nbrush = alt.selection_interval(encodings=['x'])\n\n# determine opacity based on brush\nopacity = alt.condition(brush, alt.value(0.9), alt.value(0.1))\n\n# an overview histogram of cars per year\n# add the interval brush to select cars over time\noverview = alt.Chart(cars).mark_bar().encode(\n    alt.X('Year:O', timeUnit='year', # extract year unit, treat as ordinal\n      axis=alt.Axis(title=None, labelAngle=0) # no title, no label angle\n    ),\n    alt.Y('count()', title=None), # counts, no axis title\n    opacity=opacity\n).add_selection(\n    brush      # add interval brush selection to the chart\n).properties(\n    width=400, # set the chart width to 400 pixels\n    height=50  # set the chart height to 50 pixels\n)\n\n# a detail scatterplot of horsepower vs. mileage\n# modulate point opacity based on the brush selection\ndetail = alt.Chart(cars).mark_point().encode(\n    alt.X('Horsepower'),\n    alt.Y('Miles_per_Gallon'),\n    # set opacity based on brush selection\n    opacity=opacity\n).properties(width=400) # set chart width to match the first chart\n\n# vertically concatenate (vconcat) charts using the '&' operator\noverview & detail"
  },
  {
    "objectID": "inst-221019.html#aside-examining-the-json-output",
    "href": "inst-221019.html#aside-examining-the-json-output",
    "title": "inst-221019",
    "section": "Aside: Examining the JSON Output",
    "text": "Aside: Examining the JSON Output\nAs a Python API to Vega-Lite, Altair’s main purpose is to convert plot specifications to a JSON string that conforms to the Vega-Lite schema. Using the Chart.to_json method, we can inspect the JSON specification that Altair is exporting and sending to Vega-Lite:\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='average(precip)',\n    y='city',\n)\nprint(chart.to_json())\n\n{\n  \"$schema\": \"https://vega.github.io/schema/vega-lite/v4.17.0.json\",\n  \"config\": {\n    \"view\": {\n      \"continuousHeight\": 300,\n      \"continuousWidth\": 400\n    }\n  },\n  \"data\": {\n    \"name\": \"data-fdfbb22e8e0e89f6556d8a3b434b0c97\"\n  },\n  \"datasets\": {\n    \"data-fdfbb22e8e0e89f6556d8a3b434b0c97\": [\n      {\n        \"city\": \"Seattle\",\n        \"month\": \"Apr\",\n        \"precip\": 2.68\n      },\n      {\n        \"city\": \"Seattle\",\n        \"month\": \"Aug\",\n        \"precip\": 0.87\n      },\n      {\n        \"city\": \"Seattle\",\n        \"month\": \"Dec\",\n        \"precip\": 5.31\n      },\n      {\n        \"city\": \"New York\",\n        \"month\": \"Apr\",\n        \"precip\": 3.94\n      },\n      {\n        \"city\": \"New York\",\n        \"month\": \"Aug\",\n        \"precip\": 4.13\n      },\n      {\n        \"city\": \"New York\",\n        \"month\": \"Dec\",\n        \"precip\": 3.58\n      },\n      {\n        \"city\": \"Chicago\",\n        \"month\": \"Apr\",\n        \"precip\": 3.62\n      },\n      {\n        \"city\": \"Chicago\",\n        \"month\": \"Aug\",\n        \"precip\": 3.98\n      },\n      {\n        \"city\": \"Chicago\",\n        \"month\": \"Dec\",\n        \"precip\": 2.56\n      }\n    ]\n  },\n  \"encoding\": {\n    \"x\": {\n      \"aggregate\": \"average\",\n      \"field\": \"precip\",\n      \"type\": \"quantitative\"\n    },\n    \"y\": {\n      \"field\": \"city\",\n      \"type\": \"nominal\"\n    }\n  },\n  \"mark\": \"bar\"\n}\n\n\nNotice here that encode(x='average(precip)') has been expanded to a JSON structure with a field name, a type for the data, and includes an aggregate field. The encode(y='city') statement has been expanded similarly.\nAs we saw earlier, Altair’s shorthand syntax includes a way to specify the type of the field as well:\n\nx = alt.X('average(precip):Q')\nprint(x.to_json())\n\n{\n  \"aggregate\": \"average\",\n  \"field\": \"precip\",\n  \"type\": \"quantitative\"\n}\n\n\nThis short-hand is equivalent to spelling-out the attributes by name:\n\nx = alt.X(aggregate='average', field='precip', type='quantitative')\nprint(x.to_json())\n\n{\n  \"aggregate\": \"average\",\n  \"field\": \"precip\",\n  \"type\": \"quantitative\"\n}"
  },
  {
    "objectID": "inst-221019.html#publishing-a-visualization",
    "href": "inst-221019.html#publishing-a-visualization",
    "title": "inst-221019",
    "section": "Publishing a Visualization",
    "text": "Publishing a Visualization\nOnce you have visualized your data, perhaps you would like to publish it somewhere on the web. This can be done straightforwardly using the vega-embed JavaScript package. A simple example of a stand-alone HTML document can be generated for any chart using the Chart.save method:\nchart = alt.Chart(df).mark_bar().encode(\n    x='average(precip)',\n    y='city',\n)\nchart.save('chart.html')\nThe basic HTML template produces output that looks like this, where the JSON specification for your plot produced by Chart.to_json should be stored in the spec JavaScript variable:\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"https://cdn.jsdelivr.net/npm/vega@5\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@4\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6\"></script>\n  </head>\n  <body>\n  <div id=\"vis\"></div>\n  <script>\n    (function(vegaEmbed) {\n      var spec = {}; /* JSON output for your chart's specification */\n      var embedOpt = {\"mode\": \"vega-lite\"}; /* Options for the embedding */\n\n      function showError(el, error){\n          el.innerHTML = ('<div style=\"color:red;\">'\n                          + '<p>JavaScript Error: ' + error.message + '</p>'\n                          + \"<p>This usually means there's a typo in your chart specification. \"\n                          + \"See the javascript console for the full traceback.</p>\"\n                          + '</div>');\n          throw error;\n      }\n      const el = document.getElementById('vis');\n      vegaEmbed(\"#vis\", spec, embedOpt)\n        .catch(error => showError(el, error));\n    })(vegaEmbed);\n  </script>\n</body>\n</html>\nThe Chart.save method provides a convenient way to save such HTML output to file. For more information on embedding Altair/Vega-Lite, see the documentation of the vega-embed project."
  },
  {
    "objectID": "resources.html#headline-2",
    "href": "resources.html#headline-2",
    "title": "resources",
    "section": "headline 2",
    "text": "headline 2"
  },
  {
    "objectID": "inst-221018.html",
    "href": "inst-221018.html",
    "title": "inst-221018",
    "section": "",
    "text": "# get altair graphics\nimport altair as alt\n# get data object from vega_datasets\nfrom vega_datasets import data\n\n\n# Selecting the data\ndf = data.iris()\n  \n# Making the Scatter Plot\nalt.Chart(df).mark_point().encode(\n    # Map the sepalLength to x-axis\n    x='sepalLength',\n    # Map the petalLength to y-axis\n    y='petalLength',\n    # Map the species to shape\n    shape='species',\n    #\n    color='species'\n)"
  },
  {
    "objectID": "inst-221017.html",
    "href": "inst-221017.html",
    "title": "inst-221017",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "about.html#another-head",
    "href": "about.html#another-head",
    "title": "about",
    "section": "another head",
    "text": "another head\nsome more text"
  },
  {
    "objectID": "topics-1.html#headline-2",
    "href": "topics-1.html#headline-2",
    "title": "natural language processing",
    "section": "headline 2",
    "text": "headline 2"
  },
  {
    "objectID": "instructions.html",
    "href": "instructions.html",
    "title": "instructions",
    "section": "",
    "text": "Python is a programming language that has gained popularity in all types of data science. On this introductory course, we are aiming at getting acquainted with the basic syntax of Python, as well as learning how to extend this basic functionality by calling powerful modules built by members of the large Python user community. Thus, we take a “standing on the shoulders of giants” approach to Python."
  },
  {
    "objectID": "instructions.html#teacher",
    "href": "instructions.html#teacher",
    "title": "instructions",
    "section": "teacher",
    "text": "teacher\n\n\n\nFigure 1: teacher"
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "schedule",
    "section": "",
    "text": "Python is a programming language that has gained popularity in all types of data science."
  },
  {
    "objectID": "schedule.html#headline-2",
    "href": "schedule.html#headline-2",
    "title": "schedule",
    "section": "headline 2",
    "text": "headline 2\nPython is a programming language that has gained popularity in all types of data science.\n\n\n\n\nTable 1: Some nice table caption.\n\n\n\n\n\n\n\nCourse date\nCourse topic\nPython packages\n\n\n\n\n2022-10-17\nthe anaconda3 environment, basic python syntax, process table data\nnumpy, scipy, pandas\n\n\n2022-10-18\nreproducible data analysis, data visualization, sharing and collaborating\nseaborn, altair\n\n\n2022-10-19\ntext analysis, manifest content, data cleaning, tokenization, copora\nnltk\n\n\n2022-10-20\ntext analysis, latent content features, sentiment analysis, topic modelling\nspacy\n\n\n2022-10-21\nimage analysis, latent content features, object recognition, captioning\nopencv, pytorch"
  },
  {
    "objectID": "jnb-221017.html",
    "href": "jnb-221017.html",
    "title": "inst-221017",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "topics-2.html#headline-2",
    "href": "topics-2.html#headline-2",
    "title": "computer vision",
    "section": "headline 2",
    "text": "headline 2"
  },
  {
    "objectID": "topics.html",
    "href": "topics.html",
    "title": "topics",
    "section": "",
    "text": "Python is a programming language that has gained popularity in all types of data science. On this introductory course, we are aiming at getting acquainted with the basic syntax of Python, as well as learning how to extend this basic functionality by calling powerful modules built by members of the large Python user community. Thus, we take a “standing on the shoulders of giants” approach to Python.. check out for more info.\n\n\nPython is a programming language that has gained popularity in all types of data science. On this introductory course, we are aiming at getting acquainted with the basic syntax of Python, as well as learning how to extend this basic functionality by calling powerful modules built by members of the large Python user community. Thus, we take a “standing on the shoulders of giants” approach to Python.. check out (Embarak et al., 2018) for more info.\n\n\n\nPython is a programming language that has gained popularity in all types of data science. On this introductory course, we are aiming at getting acquainted with the basic syntax of Python, as well as learning how to extend this basic functionality by calling powerful modules built by members of the large Python user community. Thus, we take a “standing on the shoulders of giants” approach to Python.. check out (Embarak et al., 2018) for more info."
  },
  {
    "objectID": "topics.html#headline-2",
    "href": "topics.html#headline-2",
    "title": "topics",
    "section": "headline 2",
    "text": "headline 2\nPython is a programming language that has gained popularity in all types of data science. On this introductory course, we are aiming at getting acquainted with the basic syntax of Python, as well as learning how to extend this basic functionality by calling powerful modules built by members of the large Python user community. Thus, we take a “standing on the shoulders of giants” approach to Python.. check out (Embarak et al., 2018) for more info."
  }
]